\chapter{Related Work}
\label{chap:related_work}

% A discussion of the related work that has been conducted before.
% Discuss how your proposed work is related (and how it advances the state of the art).

% Notes:
% - Webtracking "Einordnung" in general!
% - Attempt of mitigation directly related

% --------------------Related Work--------------------------

Tracking mechanisms are typically divided into two broad categories: stateful and stateless tracking.
Stateless tracking, also known as fingerprinting, infers a user's identity based on a combination of device-specific attributes.
Consequently, this method is hard to detect and block, but is also inherently less reliable, as small system changes may alter the fingerprint and disrupt identification.

Instead, stateful tracking relies on storing unique identifiers on the client device, most commonly through cookies or local storage.
When a user revisits a site or interacts with embedded third-party content across domains, these identifiers are sent along with requests, allowing persistent recognition.
While straightforward and highly effective, stateful tracking has become increasingly restricted through browser policies (e.g., third-party cookie blocking) and mobile platform changes such as the ability to disable the Google Advertising ID (GAID) on Android.

HyTrack \cite{USENIX:Wessels:2025} demonstrates a novel cross-app and cross-web tracking technique in the Android ecosystem by exploiting the shared cookie storage between Custom Tabs and Trusted Web Activities (TWAs).
This allows persistent tracking of users across multiple applications and the browser, even surviving user efforts to reset or sanitize their environments.
While HyTrack highlights a serious privacy vulnerability, no concrete mitigation has been proposed that balances privacy with the legitimate need for seamless web integration -- such as Single Sign-On or ad delivery -- within mobile apps.

This can be seen by taking a closer look at two mitigation strategies discussed by the authors, namely Browser State Partitioning and Forced User Interaction. 
However, both approaches introduce significant drawbacks. 
Browser state partitioning would allow each app to use its own cookie storage and hence prevent cross-app tracking.
The seamless integration of web content remains intact, as no changes to the UI are necessary, but by completely removing the browser's shared state, benign uses like Single Sign-On (SSO) or ad personalization would be broken. 

In contrast, Forced User Interaction avoids this problem by allowing the browser to use its shared cookie storage.
But this introduces a significant usability issue, as the user is forced to interact with the browser every time a web content is loaded, which not only degrades user experience but also breaks seamless integration of web content into the app.
Furthermore, this approach hands control and responsibility to the user, which is not ideal from a security perspective, as the user might be unaware of the consequences of their actions and may inadvertently enable tracking by failing to interact with the browser as required.
Other strategies, such as Limiting CTs and TWAs to First-Party Domains or introducing browser options to disable CTs and TWAs for certain domains ultimately reflect the strategies mentioned above and are therefore not effective countermeasures against HyTrack.

% How it advances the state of the art
This work addresses this gap by proposing a capability-based access control framework for Android applications using CTs and TWAs.
By wrapping Cookies into fine-grained capability tokens created by the browser according to the app developers policy, the browser decides which cookies are allowed to be stored in the (by default) shared cookie storage and which are stored in the app-specific storage, and thus not accessible to third-party libraries. 
This ensures that there is no cross-app tracking possible for untrusted third-party libraries, as each app stores its own  tracking cookie.
As the shared cookie storage still exists for domains declared as first-party or trusted by the app developer, legitimate uses of the shared browser state (e.g. SSO) are preserved.
Seamless integration of web content remains also untouched, as there is no need for user interaction or changes to the UI.
Thus, in contrast to prior discussed mitigation strategies by the authors of HyTrack, this approach provides developers with a practical and enforceable way to render cross-app tracking infeasible.

% --------------------------Suggestions-Input--------------------------------

Beyond HyTrack, other works have explored the security and privacy implications of combining native apps with embedded web content.
Georgiev et al.~\cite{georgiev2014breaking} showed how origin-based access control breaks down in hybrid frameworks and proposed techniques to enforce stricter origin policies.
Our work builds on this idea by introducing capabilities to encode both origin and app context explicitly, thereby avoiding delegation vulnerabilities.

Recent browser-level defenses like Firefox's Total Cookie Protection and Safari's Intelligent Tracking Prevention (ITP)~\cite{mozillacookies, safariitp} apply state partitioning to limit third-party tracking.
While effective in browsers, such strategies are not currently enforced in embedded contexts like CTs or TWAs.
Our solution can be seen as extending this paradigm to the app level.

Real-world abuse further illustrates the severity of cross-context tracking.
The Facebook localhost leak~\cite{localleaks} exploited Androidâ€™s intent system and redirect behavior to persistently deanonymize users across apps and browsers.
Safari's ITP also faced similar issues, where information such as the user's browsing habits could be leaked~\cite{janc2020informationleakssafarisintelligent}
These attacks reinforce the need for systematic, enforceable boundaries -- which our capability framework provides by design.

% Finally, prior work on securing Android WebViews and embedded browsers~\cite{other_android_tracking} has shown that implicit trust and shared state are common weak points in mobile security models.
% Our work contributes a practical, developer-driven mechanism to reintroduce scoping and isolation into these environments.
