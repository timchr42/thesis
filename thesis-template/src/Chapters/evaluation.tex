\chapter{Evaluation}
\label{chap:eval}

% The evaluation you want to use to assess how well you solution works.
% Provide details on verifying the stated hypotheses (experiments, subjects, measures, ...)

% Explain how you validated the concept:
% 
% - Reproduce the HyTrack baseline (show that tracking succeeds without defense).
%
% - Then test capability-based isolation:
%
%   - Does cross-app tracking stop?
% 
%   - Are legitimate features (e.g. SSO) preserved?
%
%   - Does performance or UX change?
%
% - Quantitative results: cookie behavior before/after, number of capabilities created, latency, etc.
%
% - Qualitative discussion: integration effort, compatibility, developer usability.
%
% - Optionally include screenshots, logs, or policy examples.

% Evaluation -> What resultes were observed?

% -----------------------------Evaluation---------------------------

\section{Experimental Setup}
\subsection{HyTrack Applications}

We base our evaluation on the two original HyTrack proof-of-concept applications provided by the authors: \texttt{CrossAppTrackerOne} and \texttt{CrossAppLauncher}.
Each app was prepared in two variants:

\begin{enumerate}
  \item 
    a baseline version without any policy, replicating the original HyTrack attack scenario, and

  \item
    a mitigated version including a developer-defined policy that enforces cookie isolation for the tracking domain.
\end{enumerate}

Integrating our mitigation framework into these apps required no code changes to the application logic.
Developers only need to replace the standard AndroidX Browser dependency with our modified version that supports the capability-based mitigation mechanism.
Instead of installing the apps directly, we used our custom installer, which extracts and registers the policy with the browser before installation, enabling capability issuance.

Because the original HyTrack apps relied on the Android Browser Helper library--tailored for establishing Trusted Web Activities (TWAs) with Chrome--simply switching to our enhanced Firefox browser was insufficient.
Therefore, we removed the Android Browser Helper dependency and established the required session connection to Firefox manually, allowing the apps to open TWAs (or Custom Tab fallbacks) in our modified Fenix browser.

\subsection{Test Application}

To gain deeper insight into the runtime behavior of our framework, we implemented an additional test application.
This app displays all capability tokens received from the browser when launching a Custom Tab or Trusted Web Activity to a specific domain, along with the corresponding cookies they encapsulate.

The app provides dedicated controls to launch both private and global domains--defined in its policy--to observe the browser's cookie-handling behavior.
It also illustrates policy downgrading for ambiguous configurations, and allows testing of reading and writing cookie values via the issued capabilities.
This setup provides a controlled environment to validate the correct isolation and usage of capability tokens.

\section{Results}
\subsection{Mitigation of HyTrack}

We first replicated the HyTrack attack under baseline conditions.
When both HyTrack apps were installed without a policy, the tracking domain successfully set and retrieved a persistent identifier cookie shared across both applications--confirming the presence of cross-app tracking as described in the original work.

After applying our mitigation framework with a policy marking the tracking domain as private, this behavior was eliminated.
The browser correctly issued a capability to the app encapsulating the tracking cookie, instead of storing it in its global jar.
Consequently, when the second app opened a TWA to the same domain, no cookie was sent, and the tracking domain issued a new identifier.
Each app thus maintained an independent cookie context, effectively breaking the cross-app tracking channel.

Subsequent requests within each app still reused their local capability tokens, preserving session continuity within the same app.
These results demonstrate that our mitigation successfully isolates cookie state across apps while preserving per-app continuity--a key goal of our approach.

\subsection{How the Weaknesses are addressed}
\begin{itemize}
  \item \textbf{Explicit Cookie Isolation:} Cookies are stored only if a capability for the corresponding domain exists.  
    Based on the access rights granted by the capability, cookies are either stored in the shared jar or returned to the app for isolated local storage.
  \item \textbf{App-Aware Browser Context:} Each capability encodes the app's identity and version, enabling the browser to enforce per-app cookie policies and invalidate outdated tokens.
  \item \textbf{Capability-Scoped Access Control:} Third-party domains without valid capabilities cannot access shared state, thereby blocking cross-app tracking.  
    Legitimate use cases such as Single Sign-On (SSO) remain supported if the app developer explicitly allows them in the policy.
\end{itemize}

\subsection{Verification of Design Goals}

Our system was designed with three primary goals in mind, as outlined in ~\autoref{chap:method}.
The following evaluation confirms that our implementation satisfies these goals.

\begin{enumerate}
  \item \textbf{Support for Web Platform Features.}
  All standard web platform features, including cookies, JavaScript, and modern APIs, remained fully functional throughout our evaluation, only the cookie storage behavior was altered.

  \item \textbf{Seamless Integration.}
  The mitigation operates transparently without affecting the user interface of the app or browser.
  Launching TWAs and Custom Tabs required no additional steps, and transitions between native and web content remained smooth.

  \item \textbf{Controlled Access to Shared Browser State.}
  Domains defined as private (predefined or wildcard) in the policy were correctly isolated from the global cookie jar.
  Trusted domains (e.g., SSO providers) remained accessible via the shared jar, allowing legitimate cross-app scenarios such as Single Sign-On to continue functioning as expected.
\end{enumerate}

These observations confirm that our mitigation maintains compatibility with web features, integrates seamlessly, and provides reliable control over access to shared browser state.

\subsection{Additional Behavioral Verification}

Beyond mitigating HyTrack, we verified that:

\begin{itemize}
  \item Developers can define domain- or cookie-specific isolation rules via the policy file. 
        Cookies defined as private were correctly excluded from the global jar and encapsulated in capabilities returned to the app.
  \item If an app was installed without a policy, the browser reverted to the default behavior by issuing an ambient capability, maintaining full backward compatibility.
  \item Apps defining policies but running in unmodified browsers continued to function correctly, as unrecognized capabilities were ignored.
  \item Integration effort remained minimalâ€”replacing the browser library dependency and adding a policy file were sufficient steps.
\end{itemize}

These experiments confirm that the mitigation behaves consistently across different configurations and that it can be adopted with minimal developer effort.

\section{Summary}

In summary, the evaluation confirms that the proposed mitigation framework:
\begin{itemize}
  \item effectively prevents cross-app tracking by isolating cookies on a per-app basis,
  \item maintains full compatibility with existing web features and browser mechanisms, and
  \item introduces no significant usability or integration overhead.
\end{itemize}

The evaluation confirms the correctness and feasibility of our mitigation framework. 
Next, we discuss the broader implications of these results, including their security, usability, and compatibility aspects.

The evaluation demonstrates that our capability-based mitigation framework effectively prevents cross-app tracking while maintaining full browser functionality and compatibility with existing applications. 
However, the presented results primarily focus on the technical behavior and correctness of the system. 
In the following chapter, we discuss the broader implications of these findings, relate them to our threat model and design goals, and analyze the strengths, limitations, and potential extensions of our approach.

% % Hypotheses    (ONLY NEEDED FOR PRPOSAL?)
% \section{Hypotheses}
% The evaluation is based on the following hypotheses:
% 
% \begin{enumerate}[label=H\arabic*)]
%   \item Passing capabilities with each intent enables the browser to validate and manage cookies securely and effectively. It also ensures the browser does not need to store app states.
%   \item The custom installer reliably transmits developer-defined policies to the browser.
%   \item The proposed mechanism is compatible with the original three goals of HyTrack as outlined in Section~\ref{chap:eval}.
%   \item The mechanism significantly mitigates cross-app tracking by isolating browser state based on trusted policy definitions.
%   \item The use of \textit{Ambient Capabilities} ensures backwards compatibility with existing systems.
%   \item In the case of invalid or missing capabilities, the browser by default discards the received Cookie, preventing fallback to shared state.
%   \item The proposed approach requires no modifications to existing third-party web server code.
% \end{enumerate}
% 
% % -----------------------------------------------------------------
% 
