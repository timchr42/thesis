\chapter{Evaluation}
\label{chap:eval}

% The evaluation you want to use to assess how well you solution works.
% Provide details on verifying the stated hypotheses (experiments, subjects, measures, ...)

% Explain how you validated the concept:
% 
% - Reproduce the HyTrack baseline (show that tracking succeeds without defense).
%
% - Then test capability-based isolation:
%
%   - Does cross-app tracking stop?
% 
%   - Are legitimate features (e.g. SSO) preserved?
%
%   - Does performance or UX change?
%
% - Quantitative results: cookie behavior before/after, number of capabilities created, latency, etc.
%
% - Qualitative discussion: integration effort, compatibility, developer usability.
%
% - Optionally include screenshots, logs, or policy examples.

% Evaluation -> What resultes were observed?

% -----------------------------Evaluation---------------------------

In this chapter, we present the evaluation of our mitigation framework against the HyTrack cross-app tracking attack.
We first describe the experimental setup (\autoref{sec:eval-setup}), before detailing the results (\autoref{sec:eval-results}) that we observed and finally summarizing our findings (\autoref{sec:summary}).

\section{Experimental Setup}
\label{sec:eval-setup}
For our setup, we emulated a standard Medium Phone with our modified Android 15 SDK (VanillaIceCream) installed with the proof-of-concept HyTrack applications and an additional test app.

\subsection{HyTrack Applications}
\label{sec:eval-hytrack-apps}
We base our evaluation on the two original HyTrack proof-of-concept applications provided by the authors: \texttt{CrossAppTrackerOne} and \texttt{CrossAppLauncher}.
Each app was prepared in two variants: 
(1) a baseline version without any policy, replicating the original HyTrack attack scenario, and 
(2) a mitigated version including a developer-defined policy that enforces cookie isolation for the tracking domain.

Integrating our mitigation framework into these apps required no code changes to the application logic.
Developers only need to replace the standard AndroidX Browser dependency with our modified version that supports the capability-based mitigation mechanism and add a policy file.
Instead of installing the apps directly, we used our custom installer, which extracts and forwards the policy to the browser for token generation and issuance.

Simply switching to our enhanced Firefox browser was insufficient, Because the original HyTrack apps rely on the Android Browser Helper library ~\cite{chrome:androidbrowserhelper} for launching TWAs --- a library that (among others) is tailored for establishing TWAs with Chrome for convenience. 
Therefore, we removed the Android Browser Helper dependency and established the required session connection to Firefox manually, allowing the apps to open TWAs (or Custom Tab fallbacks) in our modified Fenix browser.

\subsection{Test Application}
\label{sec:eval-test-app}
To gain deeper insight into the runtime behavior of our framework, we implemented an additional test application.
This app displays all capability tokens received from the browser when launching a Custom Tab or Trusted Web Activity to a specific domain, along with the corresponding cookies they encapsulate.

The app provides dedicated controls to launch both private and global domains (defined in its policy) to observe the browser's cookie-handling behavior.
It also illustrates policy downgrading for ambiguous configurations, and allows testing of reading and writing cookie values via the issued capabilities.
This setup provides a controlled environment to validate the correct isolation and usage of capability tokens.

\section{Results}
\label{sec:eval-results}
Our results focus on three main aspects: the mitigation of the HyTrack attack, verification of the design goals postulated by the authors of HyTrack, and highlighting the additional behaviors our mitigation provides.

\subsection{Mitigation of HyTrack}
\label{sec:eval-hytrack-mitigation}
We first replicated the HyTrack attack under baseline conditions.
When both HyTrack apps were installed without a policy, the tracking domain successfully set and retrieved a persistent identifier cookie shared across both applications, confirming the presence of cross-app tracking as described in the original work.

After applying our mitigation framework with a policy marking the tracking domain as private, this behavior was eliminated.
The browser correctly issued a capability to the app encapsulating the tracking cookie, instead of storing it in its global jar.
Consequently, when the second app opened a TWA to the same domain, no cookie was sent, and the tracking domain issued a new identifier.
Each app thus maintained an independent cookie context, effectively breaking the cross-app tracking channel.

Subsequent requests within each app still reused their local capability tokens, preserving session continuity within the same app.
These results demonstrate that our mitigation successfully isolates cookie state across apps while preserving per-app continuity --- a key goal of our approach.

\subsection{Verification of Design Goals}
\label{sec:eval-design-goals}
Our system was designed with three primary goals in mind, as outlined in ~\autoref{chap:method}.
The following evaluation confirms that our implementation satisfies these goals.

\begin{enumerate}
  \item \textbf{Support for Web Platform Features:}
  All standard web platform features, including cookies, JavaScript, and modern APIs, remained fully functional throughout our evaluation, only the cookie storage behavior was altered.

  \item \textbf{Seamless Integration:}
  The mitigation operates transparently without affecting the user interface of the app or browser.
  Launching TWAs and Custom Tabs required no additional steps, and transitions between native and web content remained smooth.

  \item \textbf{Controlled Access to Shared Browser State:}
  Domains defined as private (predefined or wildcard) in the policy were correctly isolated from the global cookie jar.
  Trusted domains (e.g., SSO providers) remained accessible via the shared jar, allowing legitimate cross-app scenarios such as Single Sign-On to continue functioning as expected.
\end{enumerate}

These observations confirm that our mitigation maintains compatibility with web features, integrates seamlessly, and provides reliable control over access to shared browser state.

\subsection{Additional Behavioral Verification}
\label{sec:eval-additional-behavior}
Beyond mitigating HyTrack, our evaluation shows that developers can express fine-grained, domain- and cookie-specific isolation rules directly through the policy file.
Cookies marked as private were correctly withheld from the global jar and instead returned to the app via encapsulated capabilities.
When an app was installed without a policy, the browser fell back to issuing an ambient capability, thereby preserving full backward compatibility.
Likewise, applications providing policies but running on an unmodified browser continued to operate normally, as unsupported capabilities were safely ignored.
As a side benefit, this separation also enables apps to perform web-based logins (via CT/TWA) using an account different from the one logged in within the browser itself.
The integration effort for developers remained minimal: replacing the browser library dependency and adding a small policy file were sufficient to enable the mitigation.

Overall, these experiments demonstrate that the framework behaves consistently across various configurations and can be adopted with very low developer overhead.

\section{Summary}
\label{sec:summary}
In summary, the evaluation confirms that the proposed mitigation framework effectively prevents cross-app tracking by isolating cookies on a per-app basis, maintains full compatibility with existing web features and browser mechanisms, and introduces no significant usability or integration overhead.

% % Hypotheses    (ONLY NEEDED FOR PRPOSAL?)
% \section{Hypotheses}
% The evaluation is based on the following hypotheses:
% 
% \begin{enumerate}[label=H\arabic*)]
%   \item Passing capabilities with each intent enables the browser to validate and manage cookies securely and effectively. It also ensures the browser does not need to store app states.
%   \item The custom installer reliably transmits developer-defined policies to the browser.
%   \item The proposed mechanism is compatible with the original three goals of HyTrack as outlined in Section~\ref{chap:eval}.
%   \item The mechanism significantly mitigates cross-app tracking by isolating browser state based on trusted policy definitions.
%   \item The use of \textit{Ambient Capabilities} ensures backwards compatibility with existing systems.
%   \item In the case of invalid or missing capabilities, the browser by default discards the received Cookie, preventing fallback to shared state.
%   \item The proposed approach requires no modifications to existing third-party web server code.
% \end{enumerate}
% 
% % -----------------------------------------------------------------
% 
