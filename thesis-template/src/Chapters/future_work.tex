\chapter{Future Work}
\label{chap:future_work}

% Policy evolution and distribution mechanisms.

% Integration with Digital Asset Links or Android permissions.

% Applicability to WebView, other browsers, or desktop environments.

% Maybe there exist a trusted authority that can declare a domain as trusted e.g. Facebook for SSO etc. for default policy? predefined policies?

% think about how to update the policy, expiration via nonce etc.

% revocation strategies?

% Developer toodling: how to create/test policies before deployment?

% Web-based policy editor?

% Capability Caching or capability handles/references instead of full tokens for performance optimization

% Generalizition beyond android

%  Eric Ackermann's Idea: 
      %HyTrack without cookies, but rather exploits the fact that the browser's cache is shalso shared across apps.
      %Combine this with hash function to create a unique identifier for the user + image in response with unique name.
      %If Webserver receives a request, it nows that the user has visited the page before and can use the image that encodes the uniue identifier (?).
      %Otherwise, the server can send a new image with a new unique identifier.

      %Solution:
      %Extens capability system to also isolate the browser cache. 
      %Trusted domains -> access to browser cache; Untrusted domains -> no access to browser cache.

      %=> Also interesting for optimitzaation of the capability system later on.

% Major Problem: Android's Custom Tabs donâ€™t preserve or expose the caller identity reliably => No way of retrieving the caller identity in the browser

    % Tried the following approaches:

    % String callingPackage = null;

    % // Method 1: getReferrer() - most reliable for modern Android (API 22+)
    % if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {
    %   Uri referrer = getReferrer();
    %   if (referrer != null) {
    %     if ("android-app".equals(referrer.getScheme())) {
    %       callingPackage = referrer.getHost(); // Package name from android-app://packagename
    %     } else {
    %       callingPackage = referrer.toString(); // Full referrer URI
    %     }
    %   }
    % }

    % // Method 2: getCallingPackage() - fallback (often null for external intents)
    % if (callingPackage == null) {
    %   callingPackage = getCallingPackage();
    % }

    % // Method 3: Intent referrer extra (fallback)
    % if (callingPackage == null && intent.hasExtra(Intent.EXTRA_REFERRER)) {
    %   Uri referrerExtra = intent.getParcelableExtra(Intent.EXTRA_REFERRER);
    %   if (referrerExtra != null && "android-app".equals(referrerExtra.getScheme())) {
    %     callingPackage = referrerExtra.getHost();
    %   }
    % }

    % // Method 4: Intent referrer name extra (another fallback)
    % if (callingPackage == null && intent.hasExtra(Intent.EXTRA_REFERRER_NAME)) {
    %   String referrerName = intent.getStringExtra(Intent.EXTRA_REFERRER_NAME);
    %   if (referrerName != null && referrerName.startsWith("android-app://")) {
    %     callingPackage = referrerName.substring("android-app://".length());
    %   }
    % }
% ---------------------------Future Work----------------------------

This thesis has laid the groundwork for mitigating cross-app tracking through shared browser state on Android by introducing a capability-based access control framework.
However, several directions for future research and development remain.

First, the proposed framework should be implemented and evaluated across additional browsers to assess its generalizability beyond the Mozilla ecosystem.
In particular, reproducing the experiments for the browsers analyzed by Wessels et al.~ in their HyTrack study ~\cite{USENIX:Wessels:2025} (Opera, Firefox, Tor Browser, UC Browser, Brave, and others) would help to determine cross-browser compatibility and highlight potential implementation challenges in differing browser architectures.

Second, the applicability of the framework should be explored on other platforms and devices, such as iOS or desktop environments, where similar shared-state mechanisms may facilitate cross-context tracking.
Extending capability-based cookie isolation to these ecosystems could provide a unified approach to mitigating state-based tracking across mobile and web platforms.

Third, future work may examine the usability and performance trade-offs of capability enforcement, developer adoption barriers, and possible integration with emerging web privacy standards such as CHIPS or Storage Partitioning.
Such investigations would contribute to a more holistic understanding of how capability-based isolation can strengthen user privacy without impairing the functionality of embedded web technologies.

Finally, for simplicity, the current prototype preserves only a cookie's name and value.
Other attributes, such as expiration time, Secure and HttpOnly flags, SameSite policies, and path or domain scope, are not yet encoded in capability tokens.
Incorporating these attributes would enable full reproduction of cookie semantics and avoid subtle mismatches between the browser's internal cookie model and the capabilities used for isolated storage.
% ------------------------------------------------------------------
