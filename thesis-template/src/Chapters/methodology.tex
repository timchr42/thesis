% How and why the system is structured that way

\chapter{Methodology}
\label{chap:method}

%\paragraph{Main Goal.}
The main research goal is to prevent HyTrack's cross-app tracking attack \cite{USENIX:Wessels:2025} by addressing the underlying weaknesses of CustomTabs (CTs) and TrustedWebActivities(TWAs) (\autoref{sec:hytrack-weaknesses}), while adhering to the design goals defined by Wessels et al. (\autoref{sec:hytrack-goals}).
Unlike previously discussed mitigation strategies such as Browser State Partitioning or Forced User Interaction (\autoref{sec:hytrack-mitigations}), the proposed approach aims to maintain usability and compatibility while providing strong privacy guarantees.

%\paragraph{Core Idea.}
The core idea is to encapsulate cookie access within fine-grained capability tokens, created and validated by the browser according to a developer-defined policy.
Depending on the policy configuration, the app receives capabilities that either allow the domain's cookies to be shared across apps or restrict them to app-specific storage.
When the app launches a URL in the browser, it transmits these capabilities along with the request.
These capabilities determine how the browser handles cookies for that session, effectively isolating or sharing them based on the developer's intentions.
This ensures that cookies from "trusted" domains intended for benign cross-app sharing are accessible to multiple apps, while cookies from "untrusted" domains remain isolated within each app's private storage and are only sent to the corresponding web server.

Consequently, this design prevents unauthorized cross-app tracking while preserving legitimate use cases such as Single Sign-On and session continuity.
Because the system operates solely at the app–browser boundary, it maintains full compatibility with existing web platform features and requires no changes to the browser UI.

\section{Capability Tokens}
Because capabilities are, by design, delegatable, we must bind them to the app's identity.
Without this binding, a malicious third-party library embedded in multiple apps could mount a collusion attack by reusing capabilities issued to another (more privileged) app, thereby bypassing the mitigation entirely.
Therefore, we include the app's unique package name in the capability tokens, so that the browser can verify that the token is only used by the app it was issued to.
A global jar flag indicates whether the cookie belongs to the shared global jar or to the app-specific isolated jar.
The cookie data itself, name and value, is encapsulated in the token, along with rights defining the permitted actions (reading, writing, or both) on the cookie data later on.
Similar to JWTs~\cite{rfc7519}, our tokens are signed to identify tampering attemtps.
Due to the threat model assumptions (\autoref{sec:threat_model}), we additionally need to encrypt the tokens, so that a malicious third-party library embedded in the app cannot read the token contents and echo them back to its web server to circumvent the mitigation.

%\paragraph{Types.}
We distinguish between \emph{Wildcard} and \emph{Final} capability tokens.
Final capabilities are fully specified tokens containing explicit cookie names and values.
They stem from wildcard tokens and represent concrete cookie instances that are used directly for cookie enforcement.
The wildcard tokens can be divided into Classic Wildcard and Predefined Capabilities.

The classic wildcard capabilities are partially specified tokens that omit cookie names and values.
Predefined capabilities are wildcard tokens that specify cookie names but omit values, providing more granular control over individual cookies.
Essentially, the wildcard tokens serve as templates from which final tokens are derived once cookies are received from a web server.

In conclusion, we design our capability tokens to be identity-bound and cryptographically protected data structures that encapsulate cookie information and metadata, enabling fine-grained access control between Android apps and the browser.

% -----------------------Explain Methodology Flow Diagram Here ---------------------------
\section{Capability-Based Cookie Isolation Flow}

To achieve this, a prototype framework named Byetrack was designed, implemented, and evaluated on Android.
The framework consists of three main components: a custom installer for policy extraction, a helper library for application integration, and modifications to Firefox for Android (Fenix Project) ~\cite{firefox:fenix} and its underlying GeckoView engine ~\cite{firefox:geckoview} to enforce cookie isolation via capability tokens.
To make our design unspoofable, we also needed to conduct modifications to the default Android operating system to securely bind capabilities to app identities.

\subsection{Developer Policy}
Developers define a JSON policy that specifies which domains may share browser state and, optionally, which cookies are expected from each domain.
This allows granular control beyond simple trusted/untrusted domain distinctions, for example, isolating third-party cookies while permitting integration with a developer's own authentication domain or SSO provider.
If no policy is provided, the browser falls back to "ambient mode", where all cookies are stored in the shared jar for backwards compatibility.

\subsection{Capability Initialization}

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{TokenInitSequenceDiagram.pdf}

  {\footnotesize\textit{Note: The grey arrows represent the original installation flow.}}
  \caption{Flow of capability initialization during app installation.}
  \label{fig:initialization_flow}
\end{figure}

During app installation, the installer extracts and transmits the policy to the browser.
The browser validates and sanitizes the policy to ensure minimal privilege, removing conflicting or ambiguous entries.  
From the sanitized policy, the browser generates capability tokens as follows:
\begin{itemize}
  \item For predefined cookie entries, the browser creates corresponding predefined capability tokens.
  \item For domain-level entries, the browser issues wildcard capabilities, marking them as global or private based on the policy.
  \item If no policy is provided, a single ambient capability is issued, reverting to the default shared-cookie behavior.
\end{itemize}

Each token is signed and encrypted before being sent to the app, which stores wildcard and final tokens in private storage for later use (\autoref{fig:initialization_flow}).
When the app is updated, the installer retransmits the policy so that the browser can reissue capabilities consistent with the new app version.

Because the app must already be installed before its policy can be transmitted to the browser, there is a small window in which a race condition may occur: if the app launches a CT or TWA before the capability tokens have been issued and stored, the browser will receive no tokens and will therefore discard any cookies set during that initial request.

\subsection{App–Browser Interaction}

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{byetrack_Flow_Flowchart_New.pdf}
  \caption{High-level overview of flow between app, browser and installer.}
  \label{fig:app_browser_interaction}
\end{figure}

We describe the methodology flow of the app–browser interaction in our Byetrack framework for CT and TWA launches, as shown in Figure~\ref{fig:app_browser_interaction}.

When an app opens a URL through a CT or TWA, the stored wildcard and (initially empty) final tokens are attached to the intent that launches the browser.
Upon receipt, the browser decrypts and validates each token by checking its signature, package name, version number, and target domain.
Invalid tokens are discarded.
The browser then uses the valid capabilities to determine how to store cookies received from the web server and to construct cookie headers for outgoing requests.

\paragraph{Cookie Reception.}  
For every received cookie, the browser applies the following logic (in order of priority):
\begin{enumerate}
  \item If the token is ambient, the cookie is stored in the global jar (default behavior).
  \item If a private predefined capability matches the cookie name, the cookie value is filled in and returned to the app for local storage.
  \item If a private wildcard capability exists, the cookie is filled in accordingly and returned to the app.
  \item If a global predefined capability matches, the cookie is stored in the shared jar.
  \item If a global wildcard capability exists, any cookie from the corresponding domain is stored in the shared jar.
  \item If no capability matches, the cookie is discarded.
\end{enumerate}

\paragraph{Cookie Transmission.}  
When constructing requests, the browser merges the cookie header derived from the final capabilities with the cookies stored in the global jar.
The latter appear in the global jar only when the app possesses a capability that authorizes global cookie storage, ensuring that each request reflects both app-specific and permitted shared state.

% ---------------------------------------------------------------------------

\subsection{Utility Interfaces}
To improve transparency and developer control, the browser exposes a small set of utility interfaces that allow an app to list the cookie names contained in its final capabilities and to read or update their corresponding values.
These utilities are necessary because, without them, an app could not access the cookies stored in its isolated jar, as they are encapsulated in encrypted capability tokens that the app cannot interpret on its own.

Access to these interfaces is strictly governed by capability rights: reading a value requires read permission, while updating it requires write permission.

\section{Design Advantages}
Beyond preventing cross-app tracking, our design provides the following key benefits, while requiring only that developers adopt our modified browser library and include a simple JSON policy file in their app.

\begin{itemize}
  \item
    \textbf{Fine-Grained Control:} Developers can precisely specify which cookies are shared or isolated.
  \item
    \textbf{Stateless Browser Design:} The browser remains stateless with respect to app-specific data, as apps retain and transmit their own tokens. The browser only needs to hold on to them temporarily during a session.
  \item
  \textbf{No Web Server Changes:} Web servers operate unmodified. The browser transparently enforces the capability model according to the app's policy it initially received.
  \item
  \textbf{Backwards Compatibility:} Apps without a policy fall back to the standard shared cookie behavior, ensuring compatibility with existing systems. Also unmodified browsers continue to function correctly with apps using the framework, as unrecognized capabilities are ignored.
\end{itemize}

\section{Alternative Design Considerations}
An alternative architecture would delegate capability generation to the installer rather than the browser.  
This would simplify the browser's responsibilities to enforcement only, reducing its complexity and eliminating installer–browser communication for each app.

It would also solve the bootstrapping problem of generating the initial capabiltities the current design faces: if an app is installed on a device, the installer notifies the browser of the new app and its policy so the browser can generate capabilities accordingly.
If this browser is not installed yet, the app cannot receive capabilities until the browser is installed and the app is reinstalled or updated.

A practical workaround for avoiding the need to reinstall or update existing apps after the browser's installation is to slightly adjust how browser applications are handled by our custom installer.
A browser does not require any capabilities for cookie access, since it acts as the policy enforcement point itself.
Consequently, when a browser application is installed, the installer can iterate over all already installed apps, collect their policies, and forward them to the newly installed browser.
The browser can then generate and issue the appropriate capabilities to each app retroactively.

Having the installer generate the capabilities directly would eliminate the need for this workaround, as it would allow an app to receive its capabilities immediately upon installation --- independent of whether a browser is present or whether it supports the framework at all.
However, this would require the installer and the browser to share a long-term secret key, introducing difficult key-distribution and key-management challenges and tightly coupling the security of both components.
For this and simplicitly reasons, the proof-of-concept implementation designates the browser as the sole trusted component for capability generation and enforcement and assumes the browser is present before app installation.


%\subsection{Token Fields}
%The following fields form the basis:
%
%\begin{itemize}
%  \item \textbf{Cookie Name and Value:} Contain the actual cookie data managed by the browser.
%  \item \textbf{Signature:} Ensures the capability was issued by the browser and has not been modified.
%  \item \textbf{Package Name:} Identifies the app that owns the capability.  
%    This prevents implicit delegation—without it, a receiving app could reuse capabilities issued to another app.
%  \item \textbf{Domain:} Specifies the target web server.  
%    The browser enforces that cookies are only valid for this domain, preventing malicious libraries from reusing capabilities to store untrusted cookies in the global jar.
%  \item \textbf{App Version Number:} Allows the browser to detect outdated tokens after app updates.  
%    Whenever the app is updated, the installer retransmits the policy so the browser can issue new capabilities consistent with the new version.
%  \item \textbf{Rights:} Define the permitted actions—reading, writing, or both—on cookie data.  
%    These rights prevent tracking libraries from exploiting browser access to extract or misuse capability contents.
%  \item \textbf{Global Jar Flag:} Indicates whether the cookie belongs to the shared global jar or to the app-specific isolated jar.
%\end{itemize}
%
%\subsection{Capability Types}
%We distinguish between \texttt{final}, \texttt{wildcard}, and \texttt{ambient} capabilities.
%
%\begin{itemize}
%  \item \textbf{Final Capabilities:} Fully specified tokens containing explicit cookie names and values.  
%    They represent concrete cookie instances and are used directly for cookie enforcement.
%  \item \textbf{Wildcard Capabilities:} Partially specified tokens that omit cookie names or values.  
%    They serve as templates from which final tokens are derived once cookies are received from a web server.
%  \item \textbf{Ambient Capabilities:} Represent the browser’s default behavior—storing all cookies in the shared global jar.  
%    These act as fallbacks when no explicit policy is provided and offer no privacy guarantees.
%\end{itemize}
