\chapter{Method: Preventing Cross-App Tracking in CTs and TWAs via Capabilities}
\label{chap:method}

% The method you want to use to address the problem.
% Explicitly state verifiable hypotheses.


% ----------------------------Methodology--------------------------

Custom Tabs (CTs) and Trusted Web Activities (TWAs) enable a seamless integration between apps and the web by sharing browser state -- most notably, session cookies.
While this enhances user experience, it also introduces a significant privacy risk: third-party libraries can exploit the shared browser state to track users across multiple apps in which they are embedded.
For instance, HyTrack demonstrates that a single shared third-party library used across multiple apps is sufficient to persistently identify and track users, bypassing conventional browser and OS sandboxing mechanisms.

% New Sections about root causes for HyTrack and how to mitigate them
\input{src/Chapters/root_causes.tex}

\section{Proposed Solution: Capability-Based Cookie Isolation}
To mitigate cross-app tracking caused by shared browser state, we propose a developer-defined policy mechanism, combined with cryptographically enforced capabilities, to control how cookies are managed and isolated on a per-app basis.

% Developer Policy Declaration
During app installation, the installer extracts and transmits the policy to the browser.
This policy -- declared by the app developer in the manifest and config file -- defines the following:
 \begin{itemize}
   \item A list of trusted domains (e.g., the developerâ€™s own domains or explicitly permitted third parties).
   \item A list of untrusted domains (e.g., third-party ad libraries).
   \item Optionally, a set of predefined cookie names expected to be used by the respective servers.
 \end{itemize}

 According to this policy, the browser creates capabilities for the app wrapping important metadata into a secure structure, encoded and signed, similar to JSON Web Tokens (JWT)~\cite{rfc7519}.
The capability structure includes the following fields:

\begin{itemize}
  \item \textbf{Signature:} Ensures the capability was issued by the browser and has not been tampered with.
  \item \textbf{App ID:} Identifies the origin of the request, ensuring that only authorized apps can hold a given capability. This field is essential to prevent implicit delegation -- without it, a receiving app could exploit the capabilities granted to the sending app and potentially gain unauthorized access.
  \item \textbf{Domain:} Specifies the designated destination web server, ensuring the capability is only sent to the correct endpoint.
  \item \textbf{App Version Number}: Indicates the version of the app to detect potential policy changes and ensure consistency between app and policy.
    In case of a version mismatch, the browser rejects these capabilities.
  \item \textbf{Rights:} Define the scope of access granted to the app -- for example, whether it may request the browser to read cookies.
    This restriction is essential to prevent libraries from exploiting browser access to extract capability values, which could otherwise be used for tracking.
  \item \textbf{Global Jar Flag:} Determines whether the shared cookie jar or an app-specific cookie jar should be used.
\end{itemize}

 Consequently, these capabilities act as \textbf{authorization tokens} for cookie access and fall into one of the following categories:

\begin{itemize}
  \item \textbf{Wildcard Capabilities:} Allow a web server to define arbitrary cookie names and values by leaving these fields unspecified in the capability, which are later filled by the browser when it receives a cookie from the web server.
    This mechanism effectively transforms conventional cookies into structured capability tokens that encapsulate metadata in addition to the cookie data.
    Hence, the app receives such a capability for each domain registered in the policy, with the difference that wildcards for trusted domains have the global jar flag set to true, while those for untrusted domains have it set to false.
    % However, for first-party domains, wildcard capabilities are unnecessary, as the developer can define explicit cookie names in advance using predefined capabilities.
  \item \textbf{Predefined Capabilities:} Define fixed cookie names as specified in the policy and can be stored either in the app-specific cookie jar or the browser's shared cookie jar, depending on the configuration of the global jar flag.
    % Shared jar can here be useful for apps developed by same entity for shared login state etc.
    This provides fine-grained control over cookie scoping and allows developers to isolate their app from the browser's state when desired, while still enabling seamless web-app integration.
  \item \textbf{Ambient Capabilities:} Instruct the browser to revert to default behavior by storing all received cookies in the global cookie jar and including them in subsequent requests to the corresponding web server.
    These have the global jar flag set by default and augment a wildcard capability with the domain name, cookie name, and corresponding value.

\textit{Ambient capabilities provide no security guarantees and serve solely as a fallback mechanism to maintain functional behavior in the absence of an explicit developer-defined policy.}
\end{itemize}

% App-to-Browser Communication via Capabilities
When the app opens a URL via CT or TWA, it includes a list of capabilities along with the regular intent containing the target URL.
The browser parses each capability and verifies its authenticity by validating its signature and associated fields.

The communication between browser and web server remains unchanged, i.e. the browser sends Request and Set-Cookie headers as usual and the web server responds with a (customized) Response and possibly new Cookies.
Upon receiving cookies, the browser matches them against the capabilities provided by the app:
\begin{enumerate}[label=\arabic*.]
  \item If the cookie name is predefined, only the value is updated in the capability.
  \item If it is new and a matching wildcard capability exists, the browser creates a new capability by duplicating the wildcard, setting the name and value accordingly and storing it in the corresponding cookie jar.
    The initial wildcard capability is then returned to the app.
  \item 
    % OLD APPROACH: 
    % If it is new and no wildcard capability exists, the browser creates a new capability with the name and value, domain and app ID, restricted rights and version number, and returns it to the app for storage in its app-specific cookie jar.
    %
    % UPDATED APPROACH:
If the cookie is new and no wildcard capability is available, the browser discards it to prevent unauthorized or unexpected state persistence.
    % \info{how does app decide what capabilities to send?}
\end{enumerate}

\section{Benefits} 
Beyond eliminating cross-app tracking through HyTrack and its postulated goals, we identify the following additional benefits offered by this approach:
\begin{enumerate}[label=B\arabic*)]
  \item \textbf{Fine-Grained Control}: Developers can specify which cookies are shared and which are isolated, allowing for a more tailored approach to privacy.
  \item \textbf{No Browser State for Apps}: The browser is stateless with respect to app-specific capabilities, as these are retained and transmitted by the app with each intent invocation.
  \item \textbf{No Third-Party Code Changes}: The web server does not need to be aware of the capabilities or make any changes to its code, as the browser handles the capability management.
  \item \textbf{Backwards Compatibility}: In case the developer does not implement its own policy, it will default to allowing any domain using the shared browser state, consequently behaving like the state-of-the art cookie management. 
\end{enumerate}

% -----------------------------------------------------------------

% Hypotheses
\section{Hypotheses}
The evaluation is based on the following hypotheses:

\begin{enumerate}[label=H\arabic*)]
  \item Passing capabilities with each intent enables the browser to validate and manage cookies securely and effectively. It also ensures the browser does not need to store app states.
  \item The custom installer reliably transmits developer-defined policies to the browser.
  \item The proposed mechanism is compatible with the original three goals of HyTrack as outlined in Section~\ref{chap:eval}.
  \item The mechanism significantly mitigates cross-app tracking by isolating browser state based on trusted policy definitions.
  \item The use of \textit{Ambient Capabilities} ensures backwards compatibility with existing systems.
  \item In the case of invalid or missing capabilities, the browser by default discards the received Cookie, preventing fallback to shared state.
  \item The proposed approach requires no modifications to existing third-party web server code.
\end{enumerate}

% -----------------------------------------------------------------

%\todo[inline]{keep components section?}
\section{Components}
In summary, implementing the proposed solution requires a combination of new components and modifications to existing ones:
\begin{itemize}
\item \textbf{Manifest} and \textbf{config file} for the developers to define which origins should retain shared browser state.
  \item A \textbf{custom installer} to extract and send the developer-defined policy to the browser upon app installation.
  \item The \textbf{browser} to function as the Policy Enforcement Point.
    For this, new functionality for validating the received policy, creating capabilities accordingly and validating them is necessary.
    In addition, the browser needs to be capable of storing a secret key for signing capabilities and verifying the signature.
    Of course, functionality for making decisions bases on the capability's context is essential, i.e. where and how to store the capability.
  \item The \textbf{app} must send capabilities as an additional parameter with each intent and store the capabilities returned by the browser for future use.
    It must also support functionality to send specific capabilities to the browser.
  \item \textbf{Capabilities} to serve as secure wrappers for cookie data, including the app ID, target domain, global jar flag, and associated access rights.
\end{itemize}

