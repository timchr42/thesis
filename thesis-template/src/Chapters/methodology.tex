\chapter{Methodology: Preventing Cross-App Tracking in CTs and TWAs via Capabilities}
\label{chap:method}

% The method you want to use to address the problem.
% Explicitly state verifiable hypotheses.


% ----------------------------Methodology--------------------------

Custom Tabs (CTs) and Trusted Web Activities (TWAs) enable a seamless integration between apps and the web by sharing browser state -- notably session cookies.
While this improves user experience, it also introduces a significant privacy concern: Third-party libraries can exploit this shared browser state to track users across apps that embed them.
HyTrack, for example, requires only a single shared third-party library used across multiple apps to persistently identify and track users, circumventing typical browser or OS sandboxing.

This solution seeks to preserve the seamless user experience of CTs/TWAs while enforcing cookie isolation across apps to prevent unauthorized cross-app tracking -- particularly from embedded third-party libraries.

\section{Proposed Solution: Capability-Based Cookie Isolation}
To address the issue, we propose a developer-defined policy mechanism paired with cryptographically enforced capabilities that dictate how cookies are managed and isolated per app.

% Developer Policy Declaration
Upon app installation, the installer extracts, error checks, encrypts and finally sends such a policy to the browser.
This policy -- declared by the app developer in the manifest and config file -- defines the following:
 \begin{itemize}
   \item A list of trusted domains (e.g., the developerâ€™s domains or selected third parties).
   \item A set of predefined cookie names expected to be used by those servers.
 \end{itemize}

 According to this policy, the browser creates capabilities for the app wrapping important cookie meta data (e.g., global jar flag, domain, name and value) into a secure structure, encoded and signed by the browser, similar to JSON Web Tokens (JWT)~\cite{rfc7519}.
 Consequently, these capabilities act as \textbf{authorization tokens} for cookie access and fall into one of the following categories:

\begin{itemize}
  \item \textbf{Wildcard Capabilities:} Allow a webserver to define arbitrary cookie names and values by leaving these fields unspecified in the capability, which are later filled by the browser when it receives a cookie from the webserver.
    This mechanism effectively transforms regular cookies into structured capabilities wrapping the cookie.
    Hence, the app receives such a capability for each domain registered in the policy.
    % However, for first-party domains, wildcard capabilities are unnecessary, as the developer can define explicit cookie names in advance using predefined capabilities.
  \item \textbf{Predefined Capabilities:} Define fixed cookie names as specified in the policy and can be stored either in the app-specific cookie jar or the browser's shared cookie jar, depending on the configuration of the global jar flag.
    % Shared jar can here be useful for apps developed by same entity for shared login state etc.
    This provides fine-grained control over cookie scoping and allows developers to isolate their app from the browser's state when desired, while still enabling seamless web-app integration.
  \item \textbf{Ambient Capabilities:} Instruct the browser to revert to default behavior by storing all received cookies in the global cookie jar and including them in subsequent requests to the corresponding web server.
    These are created by setting the global jar flag and extending a wildcard capability to include the domain name, cookie name, and value.

\textit{Ambient capabilities do not provide security guarantees and exist solely as a fallback to maintain program flow when no explicit policy is defined by the developer.}
\end{itemize}

% App-to-Browser Communication via Capabilities
When the app opens a URL via CT or TWA, it includes a list of capabilities along with the regular intent with the target URL.

The browser parses and verifies each capability by checking the following fields:
\begin{itemize}
  \item \textbf{Signature:} Ensures the capability was issued by the browser and has not been tampered with.
  \item \textbf{App ID:} Identifies the origin of the request, ensuring that only authorized apps can hold a given capability. This field is essential to prevent implicit delegation -- without it, a receiving app could exploit the capabilities granted to the sending app and potentially gain unauthorized access.
  \item \textbf{Domain:} Specifies the intended destination web server for the capability, ensuring it is sent to the correct endpoint.
  \item \textbf{App Version Number}: Indicates the version of the app to detect potential policy changes and ensure consistency between app and policy.
    In case of a version mismatch, the browser rejects these capabilities.
  \item \textbf{Rights:} Define the scope of access granted to the app -- for example, whether it may request the browser to read cookies.
    This restriction is essential to prevent libraries from exploiting browser access to extract capability values, which could otherwise be used for tracking.
  \item \textbf{Global Jar Flag:} Determines whether the shared cookie jar or an app-specific cookie jar should be used.
\end{itemize}

The communication between Browser and Webserver remains unchanged, i.e. the browser sends Request and Set-Cookie headers as usual and the webserver responds with an (customized) Response and possibly new Cookies.

The browser then matches received cookies to capabilities:
\begin{itemize}
  \item If the cookie name is predefined, only the value is updated in the capability.
  \item If it is new and a wildcard capability exists, the browser creates a new capability by copying the wildcard capability, setting the name and value accordingly and storing it in the browser's cookie jar.
    The initial wildcard capability is then sent back to the app.
  \item If it is new and no wildcard capability exists, the browser creates a new capability with the name and value, domain and app ID, restricted rights and version number, and hands it back to the app to store it in its app-specific cookie jar.
\end{itemize}

\section{Benefits} 
Beyond eliminating cross-app tracking through HyTrack and its postulated goals, we identify the following additional benefits offered by this approach:
\begin{enumerate}[label=B\arabic*)]
  \item \textbf{Fine-Grained Control}: Developers can specify which cookies are shared and which are isolated, allowing for a more tailored approach to privacy.
  \item \textbf{No Browser State for Apps}: The browser does not need to remember app capabilities -- the app holds and re-sends them with each intent.
  \item \textbf{No Third-Party Code Changes}: The webserver does not need to be aware of the capabilities or make any changes to its code, as the browser handles the capability management.
  \item \textbf{Backwards Compatibility}: In case the developer does not implement its own policy, it will default to allowing any domain using the shared browser state, consequently behaving like the state-of-the art cookie management. 
\end{enumerate}

% -----------------------------------------------------------------

% Hypotheses
\section{Hypotheses}
The evaluation is based on the following hypotheses:

\begin{enumerate}[label=H\arabic*)]
  \item Passing capabilities with each intent enables the browser to validate and manage cookies securely and effectively. It also ensures the browser does not need to store app states.
  \item The installer can transmit developer-defined policies to the browser and return them to the requesting app reliably.
  \item The proposed mechanism is compatible with the original three goals of HyTrack as outlined in Section~\ref{chap:eval}.
  \item The mechanism significantly mitigates cross-app tracking by isolating browser state based on trusted policy definitions.
  \item Backwards compatibility with existing systems can be ensured through the use of \textit{Ambient Capabilities}.
  \item In the case of invalid or missing capabilities, a default-deny policy can be enforced via empty requests, preventing fallback to shared state.
  \item The proposed approach requires no modifications to existing third-party webserver code.
\end{enumerate}

% -----------------------------------------------------------------

%\todo[inline]{keep components section?}
\section{Components}
In summary, the proposed solution requires the following components to be modified or extended:
\begin{itemize}
\item \textbf{Manifest} and \textbf{config file} for the developers to define which origins should retain shared browser state.
  \item \textbf{Custom Installer} to extract, error check, encrypt and send the developer-defined policy to the browser upon app installation.
  \item \textbf{Browser} to function as the Policy Enforcement Point.
    For this, new functionality for creating capabilities according to the policy and validating them is necessary.
    In addition, it needs to be capable of storing a secret key for signing capabilities and verifying the signature.
    Of course, decision making according to the capabilities context is unavoidable, i.e. where to store the capability, or the pair of name and value, either in the app-specific or the global cookie jar.
  \item \textbf{App} to send capabilities with each intent as an additional parameter and to store the capabilities returned by the browser.
    It must also support functionality to send specific capabilities to the browser.
  \item \textbf{Capabilities} to wrap the regular cookie data, app ID, domain, global Jar flag and rights.
\end{itemize}

