\chapter{Methodology: Preventing Cross-App Tracking in CTs and TWAs via Capabilities}
\label{chap:method}

% The method you want to use to address the problem.
% Explicitly state verifiable hypotheses.


% Current Idea: see JWT like Approach sketch

% ----------------------------Methodology--------------------------

Custom Tabs (CTs) and Trusted Web Activities (TWAs) enable a seamless integration between apps and the web by sharing browser state -- notably session cookies.
While this improves user experience, it also introduces a significant privacy concern: third-party libraries can exploit this shared browser state to track users across apps that embed them.
HyTrack, for example, requires only a single shared third-party library used across multiple apps to persistently identify and track users, circumventing typical browser or OS sandboxing.

This solution seeks to preserve the seamless user experience of CTs/TWAs while enforcing cookie isolation across apps to prevent unauthorized cross-app tracking -- particularly from embedded third-party libraries.

\section{Proposed Solution: Capability-Based Cookie Isolation}
To address the issue, we propose a developer-defined policy mechanism paired with cryptographically enforced capabilities that dictate how cookies are managed and isolated per app.

% Developer Policy Declaration
Upon app installation, the installer extracts, error checks, encrypts and subsequently sends a policy to the browser. This policy, declared by the app developer in the manifest and config file, defines the following:
 \begin{itemize}
   \item A list of trusted web servers (e.g., the developerâ€™s domains or select third parties).
   \item A set of predefined cookie names expected to be used by those servers.
 \end{itemize}

 According to this policy, the browser creates the capabilities for each app wrapping important cookie meta data (e.g., app ID, domain and name) into a secure structure -- encoded and signed by the browser similar to JWT-tokes \cite{rfc7519}.

 Consequently, these capabilities act as \textbf{authorization tokens} for cookie access and fall into one of the following categories:
\begin{itemize}
  \item \textbf{Wildcard Capabilities:} Allow the webserver to define arbitrary cookie names and values by leaving the corresponding fields empty.
    These fields are then "filled in" at runtime upon receiving a cookie and stored in the browser's cookie jar.
    Consequently, these capabilities allow conversion of regular cookies into cookie capabilities, hence each app receives such a capability for each domain it has defined in its policy.
    For first-party domains, these capabilities are not necessary, as they can be replaced by Predefined Capabilities.
  \item \textbf{Predefined Capabilities:} Have fixed cookie names as specified by the policy and can only be stored in app-specific cookie jars. This enables stricter control over cookie access and isolation.
  \item \textbf{Ambient Capabilities:} Instruct the browser to revert to default behavior by storing all received cookies in the global cookie jar and including them in subsequent requests to the corresponding web server.
    These are created by setting the global jar flag and extending a wildcard capability to include the domain name, cookie name, and value.

\textit{Ambient capabilities do not provide security guarantees and exist solely as a fallback to maintain program flow when no explicit policy is defined by the developer.}
\end{itemize}

% App-to-Browser Communication via Capabilities
When the app opens a URL via CT or TWA, it includes a list of capabilities along with the regular intent with the target URL.

The browser parses and verifies each capability by checking the following fields:
\begin{itemize}
  \item \textbf{Signature:} Ensures the capability was issued by the browser and has not been tampered with.
  \item \textbf{App ID:} Identifies the origin of the request, ensuring that only authorized apps can hold a given capability. This field is essential to prevent implicit delegation -- without it, a receiving app could exploit the capabilities granted to the sending app and potentially gain unauthorized access.
  \item \textbf{Domain:} Specifies the intended destination web server for the capability, ensuring it is send to the correct endpoint.
  \item \textbf{App Version Number}: Indicates the version of the app to detect potential policy changes and ensure consistency between app and policy.
  \item \textbf{Rights:} Define the scope of access granted to the app --for example, whether it may request the browser to read cookies.
    This restriction is essential to prevent libraries from exploiting browser access to extract capability values, which could otherwise be used for tracking.
  \item \textbf{Global Jar Flag:} Determines whether the shared cookie jar or an app-specific cookie jar should be used.
\end{itemize}

The communication between Browser and Webserver remains unchanged, i.e. the browser sends Request and Set-Cookie headers as usual and the webserver responds with an (customized) Response and possibly new Cookies.

The browser them matches received cookies to capabilities:
\begin{itemize}
  \item If the cookie name is predefined, only the value is updated in the capability.
    If the global 
  \item If it's new and a wildcard capability exists, the browser creates a new capability by copying the wildcard capability, setting the name and value accordingly and storing it in the browser's cookie jar.
    The initial wildcard capability is then sent back to the app.
  \item If it's new and no wildcard capability exists, the browser creates a new capability with the name and value, domain and app ID, restricted rights and version number, and hands it back to the app to store it in it's app-specific cookie jar.
\end{itemize}

\section{Benefits} 
Besides eliminating the possibility of cross-app tracking and the by hytrack postulated goals, we see the following additional benefits this approach offers:
\begin{enumerate}[label=B\arabic*)]
  \item \textbf{Fine-Grained Control}: Developers can specify which cookies are shared and which are isolated, allowing for a more tailored approach to privacy.
  \item \textbf{No Browser State for Apps}: The browser does not need to remember app capabilities -- the app holds and re-sends them with each intent.
  \item \textbf{No Third-Party Code Changes}: The webserver does not need to be aware of the capabilities or make any changes to its code, as the browser handles the capability management.
  \item \textbf{Backwards Compatibility}: In case the developer does not implement its own policy, it will default to allowing any domain using the shared browser state, consequently behaving like the state-of-the art cookie management. 
\end{enumerate}

% -----------------------------------------------------------------

% Hypotheses
\section{Hypotheses}
The evaluation is based on the following hypotheses:

\begin{enumerate}[label=H\arabic*)]
  \item Passing capabilities with each intent enables the browser to validate and manage cookies securely and effectively. It also ensures the browser does not need to store app states.
  \item The installer can transmit developer-defined policies to the browser and return them to the requesting app reliably.
  \item The proposed mechanism is compatible with the original three goals of HyTrack as outlined in Section~\ref{chap:eval}.
  \item The mechanism significantly mitigates cross-app tracking by isolating browser state based on trusted policy definitions.
  \item Backwards compatibility with existing systems can be ensured through the use of \textit{Ambient Capabilities}.
  \item In the case of invalid or missing capabilities, a default-deny policy can be enforced via empty requests, preventing fallback to shared state.
  \item The proposed approach requires no modifications to existing third-party webserver code.
\end{enumerate}

% -----------------------------------------------------------------

%\todo[inline]{keep components section?}
\section{Components}
In summary, the proposed solution requires the following components to be modified or extended:
\begin{itemize}
\item \textbf{Manifest} and \textbf{config file} for the developers to define which origins should retain shared browser state.
  \item \textbf{Installer} to extract, error check, encrypt and send the developer-defined policy to the browser upon app installation.
  \item \textbf{Browser} to function as Policy Enforcement Point.
    For this, new functionality for creating capabilities according to the policy and validating them is necessary.
    In addition, it needs to be capable of storing a secret key for signing capabilities and verifying the signature.
    Ofcourse, decision making according to the capabilities context is unavoidable, i.e. where to store the capability, or the pair of name and value, either in the app-specific or the global cookie jar.
  \item \textbf{App} to send capabilities with each intent and to store the capabilities returned by the browser. It must also support functionality to send specific capabilities to the browser.
  \item \textbf{Capabilities} to wrap the regular cookie data, app ID, domain, global Jar flag and rights.
\end{itemize}

