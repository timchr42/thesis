\chapter{Methodology: Preventing Cross-App Tracking in CTs and TWAs via Capabilities}
\label{chap:method}

% The method you want to use to address the problem.
% Explicitly state verifiable hypotheses.


% Current Idea: see JWT like Approach sketch

% ----------------------------Methodology--------------------------

Custom Tabs (CTs) and Trusted Web Activities (TWAs) enable a seamless integration between apps and the web by sharing browser state — notably session cookies.
While this improves user experience, it also introduces a significant privacy concern: third-party libraries can exploit this shared browser state to track users across apps that embed them.
HyTrack, for example, requires only a single shared third-party library used across multiple apps to persistently identify and track users, circumventing typical browser or OS sandboxing.

This solution seeks to preserve the seamless user experience of CTs/TWAs while enforcing cookie isolation across apps to prevent unauthorized cross-app tracking -- particularly from embedded third-party libraries.

\section{Proposed Solution: Capability-Based Cookie Isolation}
To address the issue, we propose a developer-defined policy mechanism paired with cryptographically enforced capabilities that dictate how cookies are managed and isolated per app.

% Developer Policy Declaration
 Upon app installation, the installer sends a policy crafted by the devoloper to the browser that defines:
 \begin{itemize}
   \item A list of trusted web servers (e.g., the developer’s domains or select third parties).
   \item A set of predefined cookie names expected to be used by those servers.
 \end{itemize}

 According to this policy, the browser creates a creates creates the capabilities for each app wrapping important cookie meta data (e.g., app ID, domain, name, and rights) into a secure structure-encoded and signed by the browser similar to JWT-tokes \cite{rfc7519}.

Consequently, these capabilities serve as authorization tokens for cookie access and are either:
\begin{itemize}
  \item \textbf{Wildcard Capabilities}, that allows the app to set any cookie name and value to be "filled" later or
  \item \textbf{Predefined Capabilities}, which have a fixed cookie name according to the policy and can only be stored in app-specific cookie jars.
  \item \textbf{Ambient Capabilities}, which signals the browser to behave like it would "normally" by storing any received cookie in the browsers cookie jar and including all cookies stored for certain webserver upon next requests.
    Hence, they do not provide any security and solely exists to keep the program flow from functioning in case the developer does not provide a policy!
    \unsure{check this again!}
\end{itemize}

% App-to-Browser Communication via Capabilities
When the app opens a URL via CT or TWA, it includes a list of capabilities along with the regular intent with the target URL.

The browser parses and verifies each capability by checking the following fields:
\begin{itemize}
  \item \textbf{Signature} to ensure the capability was issued by the browser and has not been tampered with.
  \item \textbf{App ID} to validate the origin, i.e. to ensure the app is authorized to use the capability.
  \item \textbf{Domain} to ensure the correct destination.
  \item \textbf{App Version Number}: to ensure the policy has not changed, i.e. to identify potential policy changes.
  \item \textbf{Rights} to restrict the access scope of the app, such as whether it can request the browser to read cookies. This is necessary to prevent libraries from using the browser to read capability values, which could otherwise be exploited for tracking.
  \item \textbf{Global Jar Flag} to determine whether to use the shared or app-specific cookie jar.
\end{itemize}

Cookies are included in the request only if the capability passes all checks.

The communication between Browser and Webserver remains unchanged, i.e. the browser sends Request and Set-Cookie headers as usual and the webserver responds with an (customized) Response and possibly new Cookies.

The browser them matches received cookies to capabilities:
\begin{itemize}
  \item If the cookie name is predefined, only the value is updated in the capability.
  \item If it's new and a wildcard capability exists, the browser creates a new capability by copying the wildcard capability and setting the name and value accordingly.
\end{itemize}

Additionally, if the global jar flag is set, the cookie is stored in the browser's cookie jar and the capability is sent back to the app. Otherwise, the capability is directly returned to the app and stored in its private app jar.

If validation fails at any point, the browser ensures a failsafe default by creating a fresh state before sending the request to the webserver, making sure that no cookies are sent along with it. 

\section{Benefits} 
Besides eliminating the possibility of cross-app tracking and the by hytrack postulated goals \unsure{reference to chap:eval where statet?},I see the following additional benefits this approach offers:
\begin{enumerate}[label=B\arabic*)]
  \item \textbf{Fine-Grained Control}: Developers can specify which cookies are shared and which are isolated, allowing for a more tailored approach to privacy.
  \item \textbf{No Browser State for Apps}: The browser does not need to remember app capabilities — the app holds and re-sends them with each intent.
  \item \textbf{No Ambient Authority}: By avoiding the need for the browser to store app states, we minimize the attack surface and potential vulnerabilities.
  \item \textbf{No Third-Party Code Changes}: The webserver does not need to be aware of the capabilities or make any changes to its code, as the browser handles the capability management.
  \item \textbf{Backwards Compatibility}: When the developer does not implement its own policy, the policy will default to allowing any webserver using the shared browser state, consequently behaving like the state of the art cookie management. 
    This is done by allowing wildcards for the domain name in addition to the cookie name and value.
    Ofcourse, for the cookie to be stored in the shared cookie jar, the global jar flag must also be set by default. \unsure{rethink this concept again! Do i even need this? in what other sense could backwards comapatibility exist?}
    \info{Maybe there exist a trusted authority that can declare a domain as trusted e.g. Facebook for SSO etc. for default policy? But also not optimal I guess}
\end{enumerate}

% -----------------------------------------------------------------

% Hypotheses
\section{Hypotheses}
My evaluation is guided by the following hypotheses:
\begin{enumerate}[label=H\arabic*)]
  \item Sending capabilities with each intent is sufficient to ensure that the browser can validate and manage cookies effectively.
  \item The installer can send the developer-defined policy to the browser and can return it to the app.
  \item The approach adheres to each goal of HytTrack (stated in \ref{chap:eval}). \unsure{own section label for the goals?}
  \item The approach fully eliminates cross-app tracking. \unsure{is this a Hypothesis?}
  \item Backwards compatibility can be implemented via "Ambient Capabilities".
  \item Empty Requests can be used to provide a failsafe default in cases of invalid capabilites.
  \item There are no code changes of webservers required.
\end{enumerate}

% -----------------------------------------------------------------

%\todo[inline]{keep components section?}
\section{Components}
In summary, the proposed solution requires the following components to be changed or added:
\begin{itemize}
  \item \textbf{Installer} to send the developer-defined policy to the browser upon app installation.
  \item \textbf{Browser} to function as Policy Enforcement Point.
    For this, new functionality for creating capabilities according to the policy and validating them is necessary.
    In addition, it needs to be capable of storing a secret key for signing capabilities and verifying the signature.
    Ofcourse, decision making according to the capabilities context is unavoidable, i.e. where to store the capability, or the pair of name and value, either in the app-specific or the global cookie jar.
  \item \textbf{App} to send capabilities with each intent and to store the capabilities returned by the browser. It must also support functionality to send specific capabilities to the browser.
\end{itemize}

