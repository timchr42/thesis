\chapter{Implementation}
\label{chap:implementation}

% Document proof-of-concept in detail:
% 
% - Describe project components:
% 
%   - Modified AndroidX Browser (launchUrl hook).
% 
%   - Modified GeckoView / Fenix (policy enforcement, token verification).
% 
%   - Installer app (policy extraction and delivery).
% 
%   - Test apps (trusted vs untrusted use cases).
% 
% - Show code-level architecture or UML overview.
% 
% - Describe technical challenges (AIDL integration, JNI bridging, content providers, duplicate class conflicts, etc.) and how you solved them.
% 
% - Highlight design decisions: choice of token format, policy schema, storage mechanisms, ...

% -----------------------------Implementation---------------------------

To demonstrate the feasibility of our mitigation strategy, we developed a proof-of-concept installer application, a new library that ships the changes and modified the androix browser library to inject our capability tokens for each call to launch a Custom Tab (CT) or Trusted Web Activity (TWA).

In this proof-of-concept, we chose the firefox mobile browser (Fenix) to act as the policy enforcement point, but it could have been any other browser the authors of HyTrack~\cite{USENIX:Wessels:2025} found out to be vulnerable to their attack, such as Chrome or Brave. %TODO: cite and check!

We modified the proof-of-concept apps provided by the authors of HyTrack and provide a test application for more insight into the framework's behavior.
For completeness, we also provide a "evil" acting app that demonstrates what the HyTrack library included in tan app could do to circumvent the mitigation.

\textit{Put a diagram here that shows the components and their interactions!!!}

\section{Policy Format}
The Byetrack policy defines the capability configuration that determines which domains are eligible to receive capability tokens and under which isolation context (global or private) they operate. The policy is expressed in a structured JSON format that is divided into two primary sections: predefined and wildcard.

Each section further distinguishes between two isolation scopes:
\begin{itemize}
  \item global -- referring to tokens or capabilities that are valid across all browser profiles or trusted applications (e.g. legitimate SSO domains).
  \item private -- referring to tokens restricted to the local application or site context (e.g. third-party trackers like the authors of HyTrack describe).
\end{itemize}

\textbf{Predefined Section:} The predefined section specifiec explicit capability bindings between domains ad the cookies that are allowed to be associated with them.
These entries define exactly which cookie names are permitted for which domains.
Each key corresponds to a domain, and the associated list defines cookie names that are explicitly authorized for that domain.
The distinction between global and private in the predefined section allows a domain to hold both a global token (usable across trusted contexts) and a private token (restricted to one context). The two scopes are treated independently and can coexist safely. %TODO Put this in Design rather?

\textbf{Wildcard Section:} The wildcard section defines simplified or implicit rules for domains where explicit cookie level definitions are not necessary.
Instead of listing cookie names, the wildcard policy only specifies domains that shall receive capability tokens defined by the isolation scope.

The wildcard and predefined entries operate independently — a domain can appear in both lists if necessary. For example, a domain may have a global predefined token for a specific cookie and a private wildcard token for general use. This allows flexible, layered control over cookie behavior. %TODO put this in Design?

An example policy with explaination can be found in the appendix \ref{appendix:policy}.

\section{Custom Installer}
The installer stored the apks of the apps to be installed in its assets folder.
This folder is read-only at runtime, so we copy the apks to the app's private storage first when an installationis initiated.
The apks uri is then installed by setting it in the intent, wich is finally launched.
As we can only read the policy with the help of the AssetManager once the apk is actually installed, we use ActivityForResult to directly continue after the installation is finished to circumvent the need to continuously poll for the installation status. 
Once the policy json file is read into a json string, it is sent to the browser together with the installed apps version and package name provided by the PackageManager by calling a designated content provider exposed by the browser.
The reason for choosing a content provider for inter process communication is that it is easy to implement by just extending the ContentProvider class and registering it in the manifest and offers functionality to receive the identity of the calling app, which is crucial for our use case.
Even though in latest Android versions (CITE HERE), there exists functionality to get the calling package name of an intent received via a broadcast, it is not reliable and in my case only returned null.
Attaching the policy, package name and version as extras to the intent and wrapping it in a pending intent is a workaround, but this faces the problem of spoofing, as the tracking library could simply create the pending intent itself and send a fake policy to the browser.
A service could be another option, but it is more complex to implement and requires more boilerplate code, even though being the more clean solution by establishing a reusable communication channel between the installer and the browser.
The downside of using a service is that the browser needs to be running in order for the installer to connect to it, which in this scenario is not guaranteed.


\section{Browser}
% State why the browser generates token and not the installer (one trusted component needs to be chosen)
The modifications conducted in the browser can be divided into two main parts: token generation and additional features in the java layer and the actual enforcement in the c++ layer. 
Despite the overlapping functionality, it was best to stricly isolate the two parts and have them "share" a secret key.
This is due to the fact that once the content provider is called, the browser is not running and therefore no GeckoRuntime exists.
Having no runtime though makes it impossible to call into the c++ layer directly from the content provider.
Trying to launch a temporary runtime to call into the c++ layer -- despite it introducing a lot of complexity and overhead -- turned out to be troublesome and error prone as it messed with the actual runtime of the browser once it was started.

\subsection{Token Generation}
Before generating any capability tokens, the browser performs a policy downgrade step to sanitize the received policy.
This step is implemented inside the TokenGenerator.generateCapabilityTokens() function and ensures that conflicting or overlapping entries are resolved according to a “minimal security” principle — meaning that private entries always take precedence over global ones, and predefined and wildcard rules remain independent.

When the content provider receives a policy from the installer, it first parses the JSON structure into four collections directly corresponding to the four sections of the policy: predefined global, predefined private, wildcard global, and wildcard private.
Each collection represents either a mapping from domains to explicit cookie names (for predefined entries), or a list of domains (for wildcard entries).

\textbf{Predefined Conflict Detection:} The first downgrade check handles domain-level and cookie-level conflicts within predefined entries.
If a domain appears in both predefined global and predefined private, the global entry is removed entirely.
If the same cookie name is found under both sections for the same domain, the global cookie is removed, keeping only the private one.
This logic is realized by iterating over the global map and comparing it to the private map and similarly for cookie-level checks.

\textbf{Wildcard Conflict Detection:} A similar check is applied to wildcard entries.
If the same domain appears in both wildcard global and wildcard private, the global entry is discarded.

\textbf{Independence Between Predefined and Wildcard Sections:} 
Importantly, predefined and wildcard rules are treated independently.
The downgrade logic explicitly avoids removing entries across these two categories.
This means that a domain can safely appear in both sections with different privilege levels. 
This independence is reflected in the implementation by simply skipping cross-type downgrades
An example can be found in the appendix \ref{appendix:policy}.

% Actual Generation Part
Once all conflicts are resolved, the downgraded policy structures are passed into the token generation routines -- processing of the predefined map and wildcard list.
These functions iterate over the filtered domain and cookie lists, creating one encrypted capability token per entry using \textit{generateSingleToken(domain, cookieName, "*", globalJar, packageName, versionName, rights);}.
As a result, only conflict-free and least-privilege tokens are ever created.

 Each token object is then encoded as a compact JSON object and serialized into a Base64-encoded string.
Finally, the encoded string is signed using hmacSHA256 and the signature attached to the token object separated with a dot, similar to JWTs ~\cite{RFC7519}, before encrypting it using AES-CBC with a random IV using the browsers secret key.
This makes the tokens tamper-evident and ensures that only the browser can generate valid tokens.

Once generated, tokens are send to the app in a map from String (domain) to JSON array via the same content provider that received the policy so that the app can persist them locally (\ref{sec:libraries}).

\subsection{Enforcement}
On receiving the intent, the browser verifies the signature, validates that the app ID and version match, and enforces the described scope and rights when deciding how to store cookies.

\subsection{Additional Features}


\section{Libraries}
\label{sec:libraries}

  \subsection{Byetrack/Mitigation} % Write Byetrack here? Prob. title change needed "Byetrack: Capabilities as a Solution ..."

  \subsection{AndroidX Browser}

\section{HyTrack Demo Apps}

\section{Test App}

\section{Evil App}

